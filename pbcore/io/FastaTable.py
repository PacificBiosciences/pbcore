from pbcore.io.base import ReaderBase
from collections import namedtuple, OrderedDict, Sequence
import mmap, numpy as np
from os.path import abspath, expanduser

__all__ = [ "FastaTable" ]

FaiRecord = namedtuple("FaiRecord", ("name", "length", "offset", "lineWidth", "stride"))

def faiFilename(fastaFilename):
    return fastaFilename + ".fai"

def loadFastaIndex(faidxFilename, fastaView):
    tbl = OrderedDict()
    try:
        #
        # `samtools faidx` mangles FASTA contig names containing a
        # space, for example, so we have to look up the true name in
        # the FASTA file itself, ignoring the name in the fai.
        #
        offsetEnd = 0
        for line in open(faidxFilename):
            length, offset, lineWidth, blen = map(int, line.split()[-4:])
            header    = fastaView[offsetEnd:offset]
            assert (header[0] == ">" and header[-1] == "\n")
            name      = header[1:-1]
            q, r = divmod(length, lineWidth)
            numNewlines = q + (r > 0)
            offsetEnd = offset + length + numNewlines
            record = FaiRecord(name, length, offset, lineWidth, blen)
            tbl[name] = record
        return tbl

    except:
        raise IOError,                                                        \
            "Companion FASTA index (.fai) file not found or malformatted! " + \
            "Use 'samtools faidx' to generate FASTA index."

def fileOffset(faiRecord, pos):
    """
    Find the in-file position (in bytes) corresponding to the position
    in the named contig, using the FASTA index.
    """
    q, r = divmod(pos, faiRecord.lineWidth)
    offset = faiRecord.offset + q*faiRecord.stride + r
    return offset

class MmappedFastaContig(Sequence):
    """
    A string-like view of a contig sequence that is backed by a file
    using mmap.
    """
    def __init__(self, view, faiRecord):
        self.view = view
        self.faiRecord = faiRecord

    def __getitem__(self, spec):
        if isinstance(spec, slice):
            start, stop, stride = spec.indices(len(self))
            if stride != 1:
                raise ValueError, "Unsupported stride"
        elif spec < 0:
            start = self.faiRecord.length + spec
            stop = start + 1
            stride = 1
        else:
            start = spec
            stop = start + 1
            stride = 1
        if not (0 <= start <= stop <= self.faiRecord.length):
            raise IndexError, "Out of bounds"
        startOffset = fileOffset(self.faiRecord, start)
        endOffset   = fileOffset(self.faiRecord, stop)
        snip = self.view[startOffset:endOffset].replace("\n", "")
        return snip

    def __len__(self):
        return self.faiRecord.length

    def __eq__(self, other):
        return (isinstance(other, MmappedFastaContig) and
                self[:] == other[:])

class FastaTableRecord(object):
    def __init__(self, view, faiRecord):
        self.view = view
        self.faiRecord = faiRecord

    @property
    def name(self):
        return self.faiRecord.name

    @property
    def sequence(self):
        return MmappedFastaContig(self.view,
                                  self.faiRecord)
    def __repr__(self):
        return "<FastaTableRecord: %s>" % self.name

    def __eq__(self, other):
        return (isinstance(other, FastaTableRecord) and
                self.name == other.name and
                self.sequence == other.sequence)


class FastaTable(ReaderBase, Sequence):
    """
    Random-access FASTA file reader.

    Requires that the lines of the FASTA file be fixed-length and that
    there is a FASTA index file (generated by `samtools faidx`) with
    name `fastaFilename.fai` in the same directory.
    """
    def __init__(self, filename):
        self.filename = abspath(expanduser(filename))
        self.file = open(self.filename, "r")
        self.view = mmap.mmap(self.file.fileno(), 0,
                              prot=mmap.PROT_READ)
        self.faiFilename = faiFilename(self.filename)
        self.fai = loadFastaIndex(self.faiFilename, self.view)
        self.contigById = dict(self.fai)
        self.contigById.update(zip(xrange(len(self.fai)),
                                   self.fai.itervalues()))

    def __getitem__(self, key):
        if key < 0:
            key = len(self) + key

        if isinstance(key, slice):
            indices = xrange(*key.indices(len(self.fai)))
            return [ FastaTableRecord(self.view, self.contigById[i])
                     for i in indices ]
        elif key in self.contigById:
            return FastaTableRecord(self.view, self.contigById[key])
        else:
            raise IndexError, "Contig not in FastaTable"

    def __iter__(self):
        return (self[key] for key in self.fai)

    def __len__(self):
        return len(self.fai)
